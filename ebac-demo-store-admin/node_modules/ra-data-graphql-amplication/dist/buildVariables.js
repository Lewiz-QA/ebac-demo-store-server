"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ra_core_1 = require("ra-core");
const getFinalType_1 = __importDefault(require("./getFinalType"));
const isList_1 = __importDefault(require("./isList"));
const NON_UPDATABLE_FIELDS = ["id", "createdAt", "updatedAt"];
const sanitizeValue = (type, value) => {
    if (type.name === "Int") {
        return parseInt(value, 10);
    }
    if (type.name === "Float") {
        return parseFloat(value);
    }
    return value;
};
const castType = (type, value) => {
    const realType = type.kind === "NON_NULL" ? type.ofType : type;
    switch (`${realType.kind}:${realType.name}`) {
        case "SCALAR:Int":
            return Number(value);
        case "SCALAR:String":
            return String(value);
        case "SCALAR:Boolean":
            return Boolean(value);
        default:
            return value;
    }
};
const prepareParams = (params, queryType, introspectionResults) => {
    const result = {};
    if (!params) {
        return params;
    }
    Object.keys(params).forEach((key) => {
        var _a;
        const param = params[key];
        let arg = null;
        if (!param) {
            result[key] = param;
            return;
        }
        if (key.endsWith(".id")) {
            return;
        }
        if (key === "target") {
            const target = param;
            if (target.endsWith("Id")) {
                result[key] = target.slice(0, -2).toLowerCase();
                return;
            }
        }
        if (queryType && Array.isArray(queryType.args)) {
            arg = queryType.args.find((item) => item.name === key);
        }
        if (param instanceof File) {
            result[key] = param;
            return;
        }
        if (param instanceof Date) {
            result[key] = param.toISOString();
            return;
        }
        if (param instanceof Object &&
            !Array.isArray(param) &&
            arg &&
            arg.type.kind === "INPUT_OBJECT") {
            const args = (_a = introspectionResults.types.find((item) => item.kind === (arg === null || arg === void 0 ? void 0 : arg.type.kind) && item.name === (arg === null || arg === void 0 ? void 0 : arg.type.name))) === null || _a === void 0 ? void 0 : _a.inputFields;
            result[key] = prepareParams(param, { args }, introspectionResults);
            return;
        }
        if (param instanceof Object &&
            !(param instanceof Date) &&
            !Array.isArray(param)) {
            result[key] = prepareParams(param, queryType, introspectionResults);
            return;
        }
        if (!arg) {
            result[key] = param;
            return;
        }
        result[key] = castType(param, arg.type);
    });
    return result;
};
const buildGetListVariables = (introspectionResults) => (resource, aorFetchType, params) => {
    let variables = {};
    if (params.filter) {
        variables.where = Object.keys(params.filter).reduce((acc, key) => {
            var _a, _b, _c, _d;
            if (key === "ids") {
                return Object.assign(Object.assign({}, acc), { ids: params.filter[key] });
            }
            if (typeof params.filter[key] === "object") {
                const type = introspectionResults.types.find((t) => t.name === `${resource.type.name}Filter`);
                const filterSome = (_b = (_a = type) === null || _a === void 0 ? void 0 : _a.inputFields) === null || _b === void 0 ? void 0 : _b.find((t) => t.name === `${key}_some`);
                if (filterSome) {
                    const filter = Object.keys(params.filter[key]).reduce((acc, k) => (Object.assign(Object.assign({}, acc), { [`${k}_in`]: params.filter[key][k] })), {});
                    return Object.assign(Object.assign({}, acc), { [`${key}_some`]: filter });
                }
            }
            const parts = key.split(".");
            if (parts.length > 1) {
                if (parts[1] === "id") {
                    const type = introspectionResults.types.find((t) => t.name === `${resource.type.name}Filter`);
                    const filterSome = (_d = (_c = type) === null || _c === void 0 ? void 0 : _c.inputFields) === null || _d === void 0 ? void 0 : _d.find((t) => t.name === `${parts[0]}_some`);
                    if (filterSome) {
                        return Object.assign(Object.assign({}, acc), { [`${parts[0]}_some`]: { id: params.filter[key] } });
                    }
                    return Object.assign(Object.assign({}, acc), { [parts[0]]: { id: params.filter[key] } });
                }
                const resourceField = resource.type.fields.find((f) => f.name === parts[0]);
                const type = getFinalType_1.default(resourceField === null || resourceField === void 0 ? void 0 : resourceField.type);
                return Object.assign(Object.assign({}, acc), { [key]: sanitizeValue(type, params.filter[key]) });
            }
            const resourceField = resource.type.fields.find((f) => f.name === key);
            if (resourceField) {
                const type = getFinalType_1.default(resourceField.type);
                const isAList = isList_1.default(resourceField.type);
                if (isAList) {
                    return Object.assign(Object.assign({}, acc), { [key]: Array.isArray(params.filter[key])
                            ? params.filter[key].map((value) => sanitizeValue(type, value))
                            : sanitizeValue(type, [params.filter[key]]) });
                }
                return Object.assign(Object.assign({}, acc), { [key]: sanitizeValue(type, params.filter[key]) });
            }
            return Object.assign(Object.assign({}, acc), { [key]: params.filter[key] });
        }, {});
    }
    if (params.pagination) {
        variables.take = parseInt(params.pagination.perPage, 10);
        variables.skip =
            (parseInt(params.pagination.page, 10) - 1) * variables.take;
    }
    if (params.sort) {
        const sortField = params.sort.field.endsWith(".id")
            ? `${params.sort.field.slice(0, -3)}Id`
            : params.sort.field;
        variables.orderBy = {
            [sortField]: params.sort.order === "DESC" ? "Desc" : "Asc",
        };
    }
    return variables;
};
const getCreateUpdateInputType = (queryType) => {
    const inputType = queryType.args.find((arg) => arg.name === "data");
    return getFinalType_1.default(inputType === null || inputType === void 0 ? void 0 : inputType.type);
};
const getInputTypeFieldsNames = (introspectionResults, typeName) => {
    const type = introspectionResults.types.find((type) => type.name === typeName && type.kind === "INPUT_OBJECT");
    return type.inputFields.map((field) => field.name);
};
const buildCreateUpdateVariables = (resource, aorFetchType, params, queryType, introspectionResults) => {
    const inputType = getCreateUpdateInputType(queryType);
    const fields = getInputTypeFieldsNames(introspectionResults, inputType.name);
    return {
        where: {
            id: params.id,
        },
        data: Object.keys(params.data).reduce((acc, key) => {
            if (NON_UPDATABLE_FIELDS.includes(key))
                return acc;
            if (!fields.includes(key))
                return acc;
            if (Array.isArray(params.data[key])) {
                const arg = queryType.args.find((a) => a.name === `${key}Ids`);
                if (arg) {
                    return Object.assign(Object.assign({}, acc), { [`${key}Ids`]: params.data[key].map(({ id }) => id) });
                }
            }
            if (typeof params.data[key] === "object") {
                const arg = queryType.args.find((a) => a.name === `${key}Id`);
                if (arg) {
                    return Object.assign(Object.assign({}, acc), { [`${key}Id`]: params.data[key].id });
                }
            }
            return Object.assign(Object.assign({}, acc), { [key]: params.data[key] });
        }, {}),
    };
};
const buildVariables = (introspectionResults) => (resource, aorFetchType, params, queryType) => {
    const preparedParams = prepareParams(params, queryType, introspectionResults);
    switch (aorFetchType) {
        case ra_core_1.GET_LIST: {
            return buildGetListVariables(introspectionResults)(resource, aorFetchType, preparedParams);
        }
        case ra_core_1.GET_MANY:
            return {
                where: { id: { in: preparedParams.ids } },
            };
        case ra_core_1.GET_MANY_REFERENCE: {
            let variables = buildGetListVariables(introspectionResults)(resource, aorFetchType, preparedParams);
            variables = Object.assign(Object.assign({}, variables), { where: {
                    [preparedParams.target]: {
                        id: preparedParams.id,
                    },
                } });
            return variables;
        }
        case ra_core_1.GET_ONE:
        case ra_core_1.DELETE:
            return {
                where: {
                    id: preparedParams.id,
                },
            };
        case ra_core_1.CREATE:
        case ra_core_1.UPDATE: {
            return buildCreateUpdateVariables(resource, aorFetchType, preparedParams, queryType, introspectionResults);
        }
    }
};
exports.default = buildVariables;
//# sourceMappingURL=buildVariables.js.map